# mysql知识点

#1.mysql中的锁分类

- 表级锁：开销小， 加锁快；不会出现死锁；锁定粒度大， 发生锁冲突的概率最高， 并发度最低。

- 行级锁：开销大， 加锁慢；会出现死锁；锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。

- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间， 并发度一般。



```python
幻读（Phantom Reads）
　　　　　　原因：事务A根据相同条件第二次查询，虽然查询不到事务B提交的新增数据，但是会影响事务A之后的一些操作，比如：事务A进行了一次select * from t1表查询，查询出id为1的数据，同时事务B进行了一次insert into t1 values(2,'xx')，也就是此时表中有了id为2的数据，但是在事务A中再次进行查询的时候，根本就查不到id为2的数据，但是当事务A进行insert into t1 values(2,'xx')，也想插入id为2的数据的时候，发现报错了，看图，但是事务A怎么查也查不到有id为2的数据，这就让事务A的使用者出现了幻觉，what happend！。如果不想出现幻读问题，那么自己在查询语句中手动加锁 for update，如果查询的是id为2的数据，即便是现在没有id为2的数据，其他事务也无法对id为2的索引位置进行数据的处理。

　　　　　　看一下幻读的现象，其他的问题的现象自行模拟吧：

事务A：
mysql> begin;
mysql> select * from t1;
+----+-------+------------+
| id | goods | order_time |
+----+-------+------------+
|  1 | a     | 2018-01-11 |
|  2 | ooo   | 2018-01-12 |
|  3 | bbb   | 2018-02-12 |
+----+-------+------------+
3 rows in set (0.00 sec)

然后事务B：
mysql> begin;
mysql> insert into t1 values(4,'ccc','2020-05-07');

mysql> select * from t1;
+----+-------+------------+
| id | goods | order_time |
+----+-------+------------+
|  1 | a     | 2018-01-11 |
|  2 | ooo   | 2018-01-12 |
|  3 | bbb   | 2018-02-12 |
|  4 | ccc   | 2020-05-07 |
+----+-------+------------+
4 rows in set (0.00 sec)

然后事务A：
mysql> select * from t1;
+----+-------+------------+
| id | goods | order_time |
+----+-------+------------+
|  1 | a     | 2018-01-11 |
|  2 | ooo   | 2018-01-12 |
|  3 | bbb   | 2018-02-12 |
+----+-------+------------+
3 rows in set (0.00 sec)

查询不到id为4的数据，接着要进行插入操作了，想插入一个id为4的数据，就报错了：
mysql> insert into t1 values(4,'xxxx','2020-05-09');
ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'
　　
```



